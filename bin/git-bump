#!/usr/bin/env bash
#
# This script takes the latest git tag (whose format follows the rules of
# semantic versioning), increments its patch number and then creates a new git
# tag using this incremented version.
#
# Suppose that you have the following tag on your repo:
#   v1.0.0
# Doing a `git bump`, the following tag will be created:
#   v1.0.1
#
# You can also pass a "matcher" (or a prefix) that will be used to filter
# different tags:
#   git bump v       (will match "v0.0.0" but not "b0.0.0")
#   git bump stable  (will match "stable0.0.0" but not "v0.0.0")
#
# By default this script increments the patch number by 1. You can change this
# behavior with the `-i` option:
#
#   git bump -i 2  (will increment the version from "v0.0.0" to "v0.0.2")
#
set -e

dir=$(dirname "${BASH_SOURCE[0]}")
source "${dir}/../lib/git.sh"
source "${dir}/../lib/utils.sh"

if ! git::repo?; then
  echo "Not a git repository." >&2
  exit 1
fi

usage() {
  cat <<EOF
usage: git bump [-h] [-i <number>] [<prefix>]
example:
  git bump              (bump from v0.0.0 to v0.0.1)
  git bump stable       (bump from stable0.0.0 to stable0.0.1)
  git bump -i 2 stable  (bump from stable0.0.0 to stable0.0.2)
EOF
}

# Defaults
increment=1
prefix=v

# Parse options
while getopts "hi:" OPTION; do
    case $OPTION in
    i)
        increment=$OPTARG
        ;;
    h)
        usage
        exit 0
        ;;
    *)
        usage
        exit 1
        ;;
    esac
done

shift "$((OPTIND-1))" # shift off the options and optional --

echo "Fetching tags..."
git fetch --tags >/dev/null 2>&1

latest_tag=$(git::latest_tag "${1-$prefix}" || :)

if [ -z "$latest_tag" ]; then
  echo "No previous tag found." >&2
  exit 1
fi

new_tag=$(semver::increment_patch "$latest_tag" "$increment")

echo "The current tag is ${latest_tag}"
echo "The new tag will be ${new_tag}"

read -n1 -p "Press [y] to continue..." -r key
echo ""

if [ "${key}" != "y" ]; then
  echo "Aborted" >&2
  exit 1
fi

git tag "${new_tag}" -m "${new_tag}"
